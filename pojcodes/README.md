pojcode
=======
I just use this project to store my codes that are my solutions on problems of [poj.org](http://poj.org/). 

[3368](http://poj.org/problem?id=3368)
-----------------------
这道题是一个很常见的问题，有两种解法，线段树和RMQ

先说一下线段树的解法：树的每一个节点记录一下几个状态：此节点区间的最高频率，左端点的值，左端点的值得延伸长度，右端点的值，和端点的值得延伸长度，
这样就可以求得最后的结果了

再说一下RMQ的解法：思想与求最大值十分类似，每一段连续的值我们可以算出个数来，这样会组成一个新的数组A，对这个数组么rmq的初始化；当查询为(l,r)时，
我们就算出l位置的值在A中的下标，r在A中的下标，边界处理一下，即l到l+1开始位置的长度，r到r开始位置的长度，然后对(ind[l]+1,ind[r]-1)区间段进行rmq
查询，取这三个值中的最大值

[1419](http://poj.org/problem?id=1419)
------------------------
直白的求最大独立集的题目，最大独立集就等于此图的补图的最大团。

求最大团的朴素算法是n*2^n的，通过dp+dfs剪枝可以对较小的图（本题节点有100个）进行求解    

[1873](http://poj.org/problem?id=1837)
------------------------
题目的关键首先要记得中学物理讲的[杠杆原理](http://baike.baidu.com/view/85069.htm)，好吧，我承认我忘记了。。。。    
之后就是想状态的事情了：dp[i][j]表示放完第i个weight后，平衡状态为j时，存在的局面数。  
那什么是平衡状态那？我们假设平衡时平衡状态为0，在左边2单位出挂一个10的砝码后，平衡状态变为-210=-20。那么我们题目的结构就是dp[G][0]的值，由于数组中不能为负值，所以加一个偏移量即可。  
状态转移方差为：   
	dp[i][j]=Sum{dp[i-1][j-C[k1]*[k2]] | 1<=k1<=|C| and 1<=k2<=|G|}

[1195](http://poj.org/problem?id=1195)
------------------------
基础的二维树状数组。借此机会也总结一下树状数组：    
![](http://my.csdn.net/uploads/201208/01/1343752270_5158.PNG)

首先要注意的是数组下标最好从1开始。     
如果我们假设数组用A表示，树状数组用C表示，则存在C[i] = A[j]+A[j+1]...+A[i]，如果i的二进制表示后面有k个0，那么j=i-2^k+1。其实k的计算很简单：   

	k=(i&(-i));     

如果数组A的某个值更新了，怎么去更新C的值呢？首先举一个例子，如果我们在4上进行了更新操作，那么C[4]的值要进行变化，紧接着C[4]的父节点C[8]的值要变化，之后是C[8]的父节点...那个C[i]的父节点怎样去计算呢？很简单：

	i+2^k

其中，k就是上述定义的值。

怎样去查询呢？也来举一个例子，我们要查询小于等于12的总和，C[12]包含4个点(k=2)，之后我们要求C[8]，其包含8个点(k=3)，Sum[12]=C[12]+C[8]。我们用二进制的形式来看，12=b1100。我们分别计算了C[b1100]和C[b1000]的值，**其实就是在不断地去掉二进制中的1**。      
这样我们可以写出更新和查询的代码了：

	void update(int index,int val):
		for(int i=index;i<=size;i+=getNext(i))
			C[i]+=val;
	
	int query(int index):
		for(int i=index;i>0;i-=getNext(i))
			ret+=C[i];
		return ret;

**时间复杂度分析：**

先看查询，对于查询下标index，其实我们for循环的迭代次数就是index二进制形式中1的个数，所以时间复杂度为O(logN)    
再看更新，我毛估估就是0的数量，O(logN)     
####**二维树状数组**####
C[i][j]表示一个二维矩阵的和：矩阵小端下标为(i-2^k1+1,j-2^k2+1)，大端下标为(i,j)，因此我们可以针对二维树状数组写一个更新查询：

	void update(int x,int y,int val):
		for(int i=x;i<=size;i+=getNext(i))
			for(int j=y;j<=size;j+=getNext(j))
				C[i][j]+=val;
	
	int query(int x,int y):
		for(int i=x;i>0;i-=getNext(i))
			for(int j=y;j>0;j-=getNext(j))
				ret+=C[i][j];
		return ret;

####**扩展问题**####
问题一：常规的一维树状数组是单点更新，区间查询。现在我们变化一下，改为区间查询，单点更新。例如：将[a,b]区间加3，求下标为c的值。     
首先说明的是，这种问题用线段树很好解决，但线段树比较一般性，建树也需要O(N)的时间复杂度。我们想想用树状数组是否可以解决：    
[a,b]区间都加v，则可以只对a加v，对b+1减v，对于查询每一个i，Sum[i]即为所求。

问题二：求逆序对    
首先要明白，利用merge sort的思想也可以求出数组的逆序对。     
现在我们想想用树状数组怎么去实现：从头遍历数组，对于i下标下的a值，将C[a]进行更新，即update(a,1)，然后查询query(a),则i-query(a)就是数组中[1,i]中大于a的数量。





